#include <libserialport.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Example of how to send and receive data.
 *
 * This example file is released to the public domain. */

/* Helper function for error handling. */
int check(enum sp_return result);
// float unpack754(uint64_t i, unsigned bits, unsigned expbits);
unsigned int GetCRC16(unsigned char *ptr, unsigned char len);

union data {
  float f;
  char c[4];
};

int main(int argc, char **argv) {
  /* This example can be used with one or two ports. With one port, it
   * will send data and try to receive it on the same port. This can be
   * done by connecting a single wire between the TX and RX pins of the
   * port.
   *
   * Alternatively it can be used with two serial ports connected to each
   * other, so that data can be sent on one and received on the other.
   * This can be done with two ports with TX/RX cross-connected, e.g. by
   * a "null modem" cable, or with a pair of interconnected virtual ports,
   * such as those created by com0com on Windows or tty0tty on Linux. */

  /* Get the port names from the command line. */
  if (argc < 2 || argc > 3) {
    printf("Usage: %s <port 1> [<port 2>]\n", argv[0]);
    return -1;
  }
  int num_ports = argc - 1;
  char **port_names = argv + 1;

  /* The ports we will use. */
  struct sp_port *ports[2];

  /* Open and configure each port. */
  for (int i = 0; i < num_ports; i++) {
    printf("Looking for port %s.\n", port_names[i]);
    check(sp_get_port_by_name(port_names[i], &ports[i]));

    printf("Opening port.\n");
    check(sp_open(ports[i], SP_MODE_READ_WRITE));

    printf("Setting port to 9600 8N1, no flow control.\n");
    check(sp_set_baudrate(ports[i], 57600));
    check(sp_set_bits(ports[i], 8));
    check(sp_set_parity(ports[i], SP_PARITY_NONE));
    check(sp_set_stopbits(ports[i], 1));
    check(sp_set_flowcontrol(ports[i], SP_FLOWCONTROL_NONE));
  }

  /* Now send some data on each port and receive it back. */
  for (int tx = 0; tx < num_ports; tx++) {
    /* Get the ports to send and receive on. */
    int rx = num_ports == 1 ? 0 : ((tx == 0) ? 1 : 0);
    struct sp_port *tx_port = ports[tx];
    struct sp_port *rx_port = ports[rx];

    union data data_Ua, data_Ub, data_Uc, data_Uab, data_Ubc, data_Uca, data_Ia,
        data_Ib, data_Ic, data_Fa, data_Fb, data_Fc, data_Sa, data_Sb, data_Sc,
        data_Ss;
    unsigned char buff_send[8];
    unsigned char buff_rec[134];
    buff_send[0] = 0x01;
    buff_send[1] = 0x03;
    buff_send[2] = 0x00;
    buff_send[3] = 0x1C;
    buff_send[4] = 0x00;
    buff_send[5] = 0x40;
    buff_send[6] = 0x85;
    buff_send[7] = 0xFC;

    unsigned int crc_result;

    int size = sizeof(buff_send);

    /* We'll allow a 1 second timeout for send and receive. */
    unsigned int timeout = 1000;

    int result;

    while (1) {
      check(sp_blocking_write(tx_port, buff_send, size, timeout));
      check(sp_blocking_read(rx_port, buff_rec, 134, timeout));
      crc_result = GetCRC16(buff_rec, 131);
      if ((buff_rec[131] == (crc_result >> 8)) &&
          (buff_rec[132] == (crc_result & 0x00FF))) {
        printf("crc successful!\n");
        int cnt = 0;
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Ua.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Ub.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Uc.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Uab.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Ubc.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Uca.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Ia.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Ib.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Ic.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Fa.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Fb.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Fc.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Sa.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Sb.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Sc.c[j] = buff_rec[cnt + 3];
        }
        for (int j = 3; j >= 0; j--, cnt++) {
          data_Ss.c[j] = buff_rec[cnt + 3];
        }

        // printf("rec: %#X %X %X %X %X %X %X %X %X %X %X %X %X %X %X %X\n",
        // 	buff_rec[0], buff_rec[1], buff_rec[2], buff_rec[3],
        // 	buff_rec[4], buff_rec[5], buff_rec[6], buff_rec[7],
        // 	buff_rec[8], buff_rec[9], buff_rec[10], buff_rec[11],
        // 	buff_rec[12], buff_rec[13], buff_rec[14], buff_rec[15]);

        printf(
            "Ua  = %.2f, Ub  = %.2f, Uc  = %.2f\nUab = %.2f, Ubc = %.2f, Uca = "
            "%.2f\nIa  = %.2f, Ib  = %.2f, Ic  = %.2f\nFa  = %.2f, Fb  = %.2f, "
            "Fc  = %.2f\nSa  = %.2f, Sb  = %.2f, Sc  = %.2f Ss  =%.2f\n",
            data_Ua.f, data_Ub.f, data_Uc.f, data_Uab.f, data_Ubc.f, data_Uca.f,
            data_Ia.f, data_Ib.f, data_Ic.f, data_Fa.f, data_Fb.f, data_Fc.f,
            data_Sa.f, data_Sb.f, data_Sc.f, data_Ss.f);
      } else
        printf("===============crc fail!===============\n");
    }
  }

  /* Close ports and free resources. */
  for (int i = 0; i < num_ports; i++) {
    check(sp_close(ports[i]));
    sp_free_port(ports[i]);
  }

  return 0;
}

/* Helper function for error handling. */
int check(enum sp_return result) {
  /* For this example we'll just exit on any error by calling abort(). */
  char *error_message;

  switch (result) {
    case SP_ERR_ARG:
      printf("Error: Invalid argument.\n");
      abort();
    case SP_ERR_FAIL:
      error_message = sp_last_error_message();
      printf("Error: Failed: %s\n", error_message);
      sp_free_error_message(error_message);
      abort();
    case SP_ERR_SUPP:
      printf("Error: Not supported.\n");
      abort();
    case SP_ERR_MEM:
      printf("Error: Couldn't allocate memory.\n");
      abort();
    case SP_OK:
    default:
      return result;
  }
}

unsigned int GetCRC16(unsigned char *ptr, unsigned char len) {
  unsigned int index;
  unsigned char crch = 0xFF;  //高CRC字节
  unsigned char crcl = 0xFF;  //低CRC字节
  unsigned char TabH[] = {
      // CRC高位字节值表
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
      0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
      0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
      0x00, 0xC1, 0x81, 0x40};
  unsigned char TabL[] = {
      // CRC低位字节值表
      0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
      0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
      0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
      0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
      0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
      0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
      0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
      0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
      0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
      0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
      0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
      0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
      0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
      0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
      0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
      0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
      0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
      0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
      0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
      0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
      0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
      0x41, 0x81, 0x80, 0x40};
  while (len--)  //计算指定长度的CRC
  {
    index = crch ^ *ptr++;
    crch = crcl ^ TabH[index];
    crcl = TabL[index];
  }

  return ((crch << 8) | crcl);  
}